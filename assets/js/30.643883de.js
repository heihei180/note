(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{343:function(e,n,a){"use strict";a.r(n);var t=a(25),l=Object(t.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"channelhandler-的生命周期"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler-的生命周期"}},[e._v("#")]),e._v(" channelHandler 的生命周期")]),e._v(" "),n("blockquote",[n("p",[e._v("在前面的小节中，对于 ChannelHandler，我们重点落在了读取数据相关的逻辑，这小节，我们来学习一下 ChannelHandler 的其他回调方法，这些回调方法的执行是有顺序的，而这个执行顺序可以称为 ChannelHandler 的生命周期。")])]),e._v(" "),n("h2",{attrs:{id:"channelhandler-的生命周期详解"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler-的生命周期详解"}},[e._v("#")]),e._v(" ChannelHandler 的生命周期详解")]),e._v(" "),n("p",[e._v("这小节，我们还是基于前面小节的代码，我们添加一个自定义 ChannelHandler 来测试一下各个回调方法的执行顺序。")]),e._v(" "),n("p",[e._v("对于服务端应用程序来说，我们这里讨论 ChannelHandler 更多的指的是 "),n("code",[e._v("ChannelInboundHandler")]),e._v("，在本小节，我们基于 "),n("code",[e._v("ChannelInboundHandlerAdapter")]),e._v("，自定义了一个 handler: "),n("code",[e._v("LifeCyCleTestHandler")])]),e._v(" "),n("blockquote",[n("p",[e._v("LifeCyCleTestHandler.java")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public class LifeCyCleTestHandler extends ChannelInboundHandlerAdapter {\n    @Override\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("逻辑处理器被添加：handlerAdded()");\n        super.handlerAdded(ctx);\n    }\n\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("channel 绑定到线程(NioEventLoop)：channelRegistered()");\n        super.channelRegistered(ctx);\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("channel 准备就绪：channelActive()");\n        super.channelActive(ctx);\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        System.out.println("channel 有数据可读：channelRead()");\n        super.channelRead(ctx, msg);\n    }\n\n    @Override\n    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("channel 某次数据读完：channelReadComplete()");\n        super.channelReadComplete(ctx);\n    }\n\n    @Override\n    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("channel 被关闭：channelInactive()");\n        super.channelInactive(ctx);\n    }\n\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("channel 取消线程(NioEventLoop) 的绑定: channelUnregistered()");\n        super.channelUnregistered(ctx);\n    }\n\n    @Override\n    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n        System.out.println("逻辑处理器被移除：handlerRemoved()");\n        super.handlerRemoved(ctx);\n    }\n}\n\n')])])]),n("p",[e._v("上面的代码可以看到，我们在每个方法被调用的时候都会打印一段文字，然后把这个事件继续往下传播。最后，我们把这个 handler 添加到我们在上小节构建的 pipeline 中")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 前面代码略\n.childHandler(new ChannelInitializer<NioSocketChannel>() {\n    protected void initChannel(NioSocketChannel ch) {\n        // 添加到第一个\n        ch.pipeline().addLast(new LifeCyCleTestHandler());\n        ch.pipeline().addLast(new PacketDecoder());\n        ch.pipeline().addLast(new LoginRequestHandler());\n        ch.pipeline().addLast(new MessageRequestHandler());\n        ch.pipeline().addLast(new PacketEncoder());\n    }\n});\n\n")])])]),n("p",[e._v("接着，我们先运行 "),n("code",[e._v("NettyServer.java")]),e._v("，然后再运行 "),n("code",[e._v("NettyClient.java")]),e._v("，这个时候，Server 端 控制台的输出为")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/2/166354fddf98cfa6?w=1954&h=680&f=jpeg&s=256279",alt:""}})]),e._v(" "),n("p",[e._v("可以看到，ChannelHandler 回调方法的执行顺序为")]),e._v(" "),n("p",[n("code",[e._v("handlerAdded() -> channelRegistered() -> channelActive() -> channelRead() -> channelReadComplete()")])]),e._v(" "),n("p",[e._v("下面，我们来逐个解释一下每个回调方法的含义")]),e._v(" "),n("ol",[n("li",[n("code",[e._v("handlerAdded()")]),e._v(" ：指的是当检测到新连接之后，调用 "),n("code",[e._v("ch.pipeline().addLast(new LifeCyCleTestHandler());")]),e._v(" 之后的回调，表示在当前的 channel 中，已经成功添加了一个 handler 处理器。")]),e._v(" "),n("li",[n("code",[e._v("channelRegistered()")]),e._v("：这个回调方法，表示当前的 channel 的所有的逻辑处理已经和某个 NIO 线程建立了绑定关系，类似我们在"),n("a",{attrs:{href:"https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4bc28b5188251b1f224ee5",target:"_blank",rel:"noopener noreferrer"}},[e._v("Netty 是什么？"),n("OutboundLink")],1),e._v("这小节中 BIO 编程中，accept 到新的连接，然后创建一个线程来处理这条连接的读写，只不过 Netty 里面是使用了线程池的方式，只需要从线程池里面去抓一个线程绑定在这个 channel 上即可，这里的 NIO 线程通常指的是 "),n("code",[e._v("NioEventLoop")]),e._v(",不理解没关系，后面我们还会讲到。")]),e._v(" "),n("li",[n("code",[e._v("channelActive()")]),e._v("：当 channel 的所有的业务逻辑链准备完毕（也就是说 channel 的 pipeline 中已经添加完所有的 handler）以及绑定好一个 NIO 线程之后，这条连接算是真正激活了，接下来就会回调到此方法。")]),e._v(" "),n("li",[n("code",[e._v("channelRead()")]),e._v("：客户端向服务端发来数据，每次都会回调此方法，表示有数据可读。")]),e._v(" "),n("li",[n("code",[e._v("channelReadComplete()")]),e._v("：服务端每次读完一次完整的数据之后，回调该方法，表示数据读取完毕。")])]),e._v(" "),n("p",[e._v("接下来，我们再把客户端关闭，这个时候对于服务端来说，其实就是 channel 被关闭")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/2/166354fddf71c162?w=1414&h=144&f=jpeg&s=50905",alt:""}})]),e._v(" "),n("p",[e._v("ChannelHandler 回调方法的执行顺序为")]),e._v(" "),n("p",[n("code",[e._v("channelInactive() -> channelUnregistered() -> handlerRemoved()")])]),e._v(" "),n("p",[e._v("到了这里，相信大家应该已经能够看到，这里的回调方法的执行顺序是新连接建立时候的逆操作，下面我们还是来解释一下每个方法的含义")]),e._v(" "),n("ol",[n("li",[n("code",[e._v("channelInactive()")]),e._v(": 表面这条连接已经被关闭了，这条连接在 TCP 层面已经不再是 ESTABLISH 状态了")]),e._v(" "),n("li",[n("code",[e._v("channelUnregistered()")]),e._v(": 既然连接已经被关闭，那么与这条连接绑定的线程就不需要对这条连接负责了，这个回调就表明与这条连接对应的 NIO 线程移除掉对这条连接的处理")]),e._v(" "),n("li",[n("code",[e._v("handlerRemoved()")]),e._v("：最后，我们给这条连接上添加的所有的业务逻辑处理器都给移除掉。")])]),e._v(" "),n("p",[e._v("最后，我们用一幅图来标识 ChannelHandler 的生命周期")]),e._v(" "),n("p",[n("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/10/14/1666fdc2bdcf3f9e?w=2176&h=658&f=png&s=104798",alt:""}})]),e._v(" "),n("p",[e._v("光是了解这些生命周期的回调方法其实是比较枯燥乏味的，我们接下来就来看一下这些回调方法的使用场景")]),e._v(" "),n("h2",{attrs:{id:"channelhandler-生命周期各回调方法用法举例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler-生命周期各回调方法用法举例"}},[e._v("#")]),e._v(" ChannelHandler 生命周期各回调方法用法举例")]),e._v(" "),n("p",[e._v("Netty 对于一条连接的在各个不同状态下回调方法的定义还是蛮细致的，这个好处就在于我们能够基于这个机制写出扩展性较好的应用程序。")]),e._v(" "),n("h3",{attrs:{id:"_1-channelinitializer-的实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-channelinitializer-的实现原理"}},[e._v("#")]),e._v(" 1. ChannelInitializer 的实现原理")]),e._v(" "),n("p",[e._v("仔细翻看一下我们的服务端启动代码，我们在给新连接定义 handler 的时候，其实只是通过 "),n("code",[e._v("childHandler()")]),e._v(" 方法给新连接设置了一个 handler，这个 handler 就是 "),n("code",[e._v("ChannelInitializer")]),e._v("，而在 "),n("code",[e._v("ChannelInitializer")]),e._v(" 的 "),n("code",[e._v("initChannel()")]),e._v(" 方法里面，我们通过拿到 channel 对应的 pipeline，然后往里面塞 handler")]),e._v(" "),n("blockquote",[n("p",[e._v("NettyServer.java")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(".childHandler(new ChannelInitializer<NioSocketChannel>() {\n    protected void initChannel(NioSocketChannel ch) {\n        ch.pipeline().addLast(new LifeCyCleTestHandler());\n        ch.pipeline().addLast(new PacketDecoder());\n        ch.pipeline().addLast(new LoginRequestHandler());\n        ch.pipeline().addLast(new MessageRequestHandler());\n        ch.pipeline().addLast(new PacketEncoder());\n    }\n});\n\n")])])]),n("p",[e._v("这里的 "),n("code",[e._v("ChannelInitializer")]),e._v(" 其实就利用了 Netty 的 handler 生命周期中 "),n("code",[e._v("channelRegistered()")]),e._v(" 与 "),n("code",[e._v("handlerAdded()")]),e._v(" 两个特性，我们简单翻一翻 "),n("code",[e._v("ChannelInitializer")]),e._v(" 这个类的源代码：")]),e._v(" "),n("blockquote",[n("p",[e._v("ChannelInitializer.java")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    protected abstract void initChannel(C ch) throws Exception;\n\n    public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        // ...\n        initChannel(ctx);\n        // ...\n    }\n\n    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n        // ...\n        if (ctx.channel().isRegistered()) {\n            initChannel(ctx);\n        }\n        // ...\n    }\n\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) {\n            initChannel((C) ctx.channel());\n            // ...\n            return true;\n        }\n        return false;\n    }\n\n")])])]),n("p",[e._v("这里，我把非重点代码略去，逻辑会更加清晰一些")]),e._v(" "),n("ol",[n("li",[n("code",[e._v("ChannelInitializer")]),e._v(" 定义了一个抽象的方法 "),n("code",[e._v("initChannel()")]),e._v("，这个抽象方法由我们自行实现，我们在服务端启动的流程里面的实现逻辑就是往 pipeline 里面塞我们的 handler 链")]),e._v(" "),n("li",[n("code",[e._v("handlerAdded()")]),e._v(" 和 "),n("code",[e._v("channelRegistered()")]),e._v(" 方法，都会尝试去调用 "),n("code",[e._v("initChannel()")]),e._v(" 方法，"),n("code",[e._v("initChannel()")]),e._v(" 使用 "),n("code",[e._v("putIfAbsent()")]),e._v(" 来防止 "),n("code",[e._v("initChannel()")]),e._v(" 被调用多次")]),e._v(" "),n("li",[e._v("如果你 debug 了 "),n("code",[e._v("ChannelInitializer")]),e._v(" 的上述两个方法，你会发现，在 "),n("code",[e._v("handlerAdded()")]),e._v(" 方法被调用的时候，channel 其实已经和某个线程绑定上了，所以，就我们的应用程序来说，这里的 "),n("code",[e._v("channelRegistered()")]),e._v(" 其实是多余的，那为什么这里还要尝试调用一次呢？我猜测应该是担心我们自己写了个类继承自 "),n("code",[e._v("ChannelInitializer")]),e._v("，然后覆盖掉了 "),n("code",[e._v("handlerAdded()")]),e._v(" 方法，这样即使覆盖掉，在 "),n("code",[e._v("channelRegistered()")]),e._v(" 方法里面还有机会再调一次 "),n("code",[e._v("initChannel()")]),e._v("，把我们自定义的 handler 都添加到 pipeline 中去。")])]),e._v(" "),n("h3",{attrs:{id:"_2-handleradded-与-handlerremoved"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-handleradded-与-handlerremoved"}},[e._v("#")]),e._v(" 2. handlerAdded() 与 handlerRemoved()")]),e._v(" "),n("p",[e._v("这两个方法通常可以用在一些资源的申请和释放")]),e._v(" "),n("h3",{attrs:{id:"_3-channelactive-与-channelinactive"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-channelactive-与-channelinactive"}},[e._v("#")]),e._v(" 3. channelActive() 与 channelInActive()")]),e._v(" "),n("ol",[n("li",[e._v("对我们的应用程序来说，这两个方法表明的含义是 TCP 连接的建立与释放，通常我们在这两个回调里面统计单机的连接数，"),n("code",[e._v("channelActive()")]),e._v(" 被调用，连接数加一，"),n("code",[e._v("channelInActive()")]),e._v(" 被调用，连接数减一")]),e._v(" "),n("li",[e._v("另外，我们也可以在 "),n("code",[e._v("channelActive()")]),e._v(" 方法中，实现对客户端连接 ip 黑白名单的过滤，具体这里就不展开了")])]),e._v(" "),n("h3",{attrs:{id:"_4-channelread"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-channelread"}},[e._v("#")]),e._v(" 4. channelRead()")]),e._v(" "),n("p",[e._v("我们在前面小节讲拆包粘包原理，服务端根据自定义协议来进行拆包，其实就是在这个方法里面，每次读到一定的数据，都会累加到一个容器里面，然后判断是否能够拆出来一个完整的数据包，如果够的话就拆了之后，往下进行传递，这里就不过多展开，感兴趣的同学可以阅读一下")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://www.jianshu.com/p/dc26e944da95",target:"_blank",rel:"noopener noreferrer"}},[e._v("netty源码分析之拆包器的奥秘"),n("OutboundLink")],1)]),e._v(" "),n("h3",{attrs:{id:"_5-channelreadcomplete"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-channelreadcomplete"}},[e._v("#")]),e._v(" 5. channelReadComplete()")]),e._v(" "),n("p",[e._v("前面小节中，我们在每次向客户端写数据的时候，都通过 "),n("code",[e._v("writeAndFlush()")]),e._v(" 的方法写并刷新到底层，其实这种方式不是特别高效，我们可以在之前调用 "),n("code",[e._v("writeAndFlush()")]),e._v(" 的地方都调用 "),n("code",[e._v("write()")]),e._v(" 方法，然后在这个方面里面调用 "),n("code",[e._v("ctx.channel().flush()")]),e._v(" 方法，相当于一个批量刷新的机制，当然，如果你对性能要求没那么高，"),n("code",[e._v("writeAndFlush()")]),e._v(" 足矣。")]),e._v(" "),n("p",[e._v("关于 ChannelHandler 的生命周期相关的内容我们就讲到这，最后，我们对本小节内容作下总结")]),e._v(" "),n("h2",{attrs:{id:"总结"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),n("ol",[n("li",[e._v("我们详细剖析了 ChannelHandler（主要是"),n("code",[e._v("ChannelInBoundHandler")]),e._v("）的各个回调方法，连接的建立和关闭，执行回调方法有个逆向的过程")]),e._v(" "),n("li",[e._v("每一种回调方法都有他各自的用法，但是有的时候某些回调方法的使用边界有些模糊，恰当地使用回调方法来处理不同的逻辑，可以使你的应用程序更为优雅。")])]),e._v(" "),n("h2",{attrs:{id:"思考"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[e._v("#")]),e._v(" 思考")]),e._v(" "),n("ol",[n("li",[e._v("在服务端每隔一秒输出当前客户端的连接数，当然了，你需要建立多个客户端。")]),e._v(" "),n("li",[e._v("统计客户端的入口流量，以字节为单位。")])]),e._v(" "),n("p",[e._v("欢迎留言一起讨论。")])])}),[],!1,null,null,null);n.default=l.exports}}]);