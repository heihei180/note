(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{538:function(e,t,n){"use strict";n.r(t);var a=n(27),s=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"实战-实现客户端与服务端收发消息"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战-实现客户端与服务端收发消息"}},[e._v("#")]),e._v(" 实战：实现客户端与服务端收发消息")]),e._v(" "),t("blockquote",[t("p",[e._v("这一小节，我们来实现客户端与服务端收发消息，我们要实现的具体功能是：在控制台输入一条消息之后按回车，校验完客户端的登录状态之后，把消息发送到服务端，服务端收到消息之后打印并且向客户端发送一条消息，客户端收到之后打印。")])]),e._v(" "),t("h2",{attrs:{id:"收发消息对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#收发消息对象"}},[e._v("#")]),e._v(" 收发消息对象")]),e._v(" "),t("p",[e._v("首先，我们来定义一下客户端与服务端的收发消息对象，我们把客户端发送至服务端的消息对象定义为 "),t("code",[e._v("MessageRequestPacket")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@Data\npublic class MessageRequestPacket extends Packet {\n\n    private String message;\n\n    @Override\n    public Byte getCommand() {\n        return MESSAGE_REQUEST;\n    }\n}\n\n")])])]),t("p",[e._v("指令为 "),t("code",[e._v("MESSAGE_REQUEST ＝ 3")])]),e._v(" "),t("p",[e._v("我们把服务端发送至客户端的消息对象定义为 "),t("code",[e._v("MessageResponsePacket")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("@Data\npublic class MessageResponsePacket extends Packet {\n\n    private String message;\n\n    @Override\n    public Byte getCommand() {\n\n        return MESSAGE_RESPONSE;\n    }\n}\n\n")])])]),t("p",[e._v("指令为 "),t("code",[e._v("MESSAGE_RESPONSE = 4")])]),e._v(" "),t("p",[e._v("至此，我们的指令已经有如下四种")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public interface Command {\n\n    Byte LOGIN_REQUEST = 1;\n\n    Byte LOGIN_RESPONSE = 2;\n\n    Byte MESSAGE_REQUEST = 3;\n\n    Byte MESSAGE_RESPONSE = 4;\n}\n\n")])])]),t("h2",{attrs:{id:"判断客户端是否登录成功"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#判断客户端是否登录成功"}},[e._v("#")]),e._v(" 判断客户端是否登录成功")]),e._v(" "),t("p",[e._v("在"),t("a",{attrs:{href:"https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4db04be51d45191556ee9c",target:"_blank",rel:"noopener noreferrer"}},[e._v("前面一小节"),t("OutboundLink")],1),e._v("，我们在文末出了一道思考题：如何判断客户端是否已经登录？")]),e._v(" "),t("p",[e._v("在"),t("a",{attrs:{href:"https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4dafd4f265da0f98314cc7",target:"_blank",rel:"noopener noreferrer"}},[e._v("客户端启动流程"),t("OutboundLink")],1),e._v("这一章节，我们有提到可以给客户端连接，也就是 Channel 绑定属性，通过 "),t("code",[e._v("channel.attr(xxx).set(xx)")]),e._v(" 的方式，那么我们是否可以在登录成功之后，给 Channel 绑定一个登录成功的标志位，然后判断是否登录成功的时候取出这个标志位就可以了呢？答案是肯定的")]),e._v(" "),t("p",[e._v("我们先来定义一下是否登录成功的标志位")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public interface Attributes {\n    AttributeKey<Boolean> LOGIN = AttributeKey.newInstance("login");\n}\n\n')])])]),t("p",[e._v("然后，我们在客户端登录成功之后，给客户端绑定登录成功的标志位")]),e._v(" "),t("blockquote",[t("p",[e._v("ClientHandler.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void channelRead(ChannelHandlerContext ctx, Object msg) {\n    // ...\n        if (loginResponsePacket.isSuccess()) {\n            LoginUtil.markAsLogin(ctx.channel());\n            System.out.println(new Date() + ": 客户端登录成功");\n        } else {\n            System.out.println(new Date() + ": 客户端登录失败，原因：" + loginResponsePacket.getReason());\n        }\n    // ...\n}\n\n\n')])])]),t("p",[e._v("这里，我们省去了非关键代码部分")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class LoginUtil {\n    public static void markAsLogin(Channel channel) {\n        channel.attr(Attributes.LOGIN).set(true);\n    }\n\n    public static boolean hasLogin(Channel channel) {\n        Attribute<Boolean> loginAttr = channel.attr(Attributes.LOGIN);\n\n        return loginAttr.get() != null;\n    }\n}\n\n")])])]),t("p",[e._v("如上所示，我们抽取出 "),t("code",[e._v("LoginUtil")]),e._v(" 用于设置登录标志位以及判断是否有标志位，如果有标志位，不管标志位的值是什么，都表示已经成功登录过，接下来，我们来实现控制台输入消息并发送至服务端。")]),e._v(" "),t("h2",{attrs:{id:"控制台输入消息并发送"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制台输入消息并发送"}},[e._v("#")]),e._v(" 控制台输入消息并发送")]),e._v(" "),t("p",[e._v("在"),t("a",{attrs:{href:"https://juejin.im/book/5b4bc28bf265da0f60130116/section/5b4daf9ee51d4518f543f130",target:"_blank",rel:"noopener noreferrer"}},[e._v("客户端启动"),t("OutboundLink")],1),e._v("这小节中，我们已经学到了客户端的启动流程，现在，我们在客户端连接上服务端之后启动控制台线程，从控制台获取消息，然后发送至服务端")]),e._v(" "),t("blockquote",[t("p",[e._v("NettyClient.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('\nprivate static void connect(Bootstrap bootstrap, String host, int port, int retry) {\n    bootstrap.connect(host, port).addListener(future -> {\n        if (future.isSuccess()) {\n            Channel channel = ((ChannelFuture) future).channel();\n            // 连接成功之后，启动控制台线程\n            startConsoleThread(channel);\n        } \n        // ...\n    });\n}\n\nprivate static void startConsoleThread(Channel channel) {\n    new Thread(() -> {\n        while (!Thread.interrupted()) {\n            if (LoginUtil.hasLogin(channel)) {\n                System.out.println("输入消息发送至服务端: ");\n                Scanner sc = new Scanner(System.in);\n                String line = sc.nextLine();\n                \n                MessageRequestPacket packet = new MessageRequestPacket();\n                packet.setMessage(line);\n                ByteBuf byteBuf = PacketCodeC.INSTANCE.encode(channel.alloc(), packet);\n                channel.writeAndFlush(byteBuf);\n            }\n        }\n    }).start();\n}\n\n')])])]),t("p",[e._v("这里，我们省略了非关键代码，连接成功之后，我们调用 "),t("code",[e._v("startConsoleThread()")]),e._v(" 开始启动控制台线程，然后在控制台线程中，判断只要当前 channel 是登录状态，就允许控制台输入消息。")]),e._v(" "),t("p",[e._v("从控制台获取消息之后，将消息封装成消息对象，然后将消息编码成 "),t("code",[e._v("ByteBuf")]),e._v("，最后通过 "),t("code",[e._v("writeAndFlush()")]),e._v(" 将消息写到服务端，这个过程相信大家在学习了上小节的内容之后，应该不会太陌生。接下来，我们来看一下服务端收到消息之后是如何来处理的。")]),e._v(" "),t("h2",{attrs:{id:"服务端收发消息处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#服务端收发消息处理"}},[e._v("#")]),e._v(" 服务端收发消息处理")]),e._v(" "),t("blockquote",[t("p",[e._v("ServerHandler.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void channelRead(ChannelHandlerContext ctx, Object msg) {\n    ByteBuf requestByteBuf = (ByteBuf) msg;\n\n    Packet packet = PacketCodeC.INSTANCE.decode(requestByteBuf);\n\n    if (packet instanceof LoginRequestPacket) {\n        // 处理登录..\n    } else if (packet instanceof MessageRequestPacket) {\n        // 处理消息\n        MessageRequestPacket messageRequestPacket = ((MessageRequestPacket) packet);\n        System.out.println(new Date() + ": 收到客户端消息: " + messageRequestPacket.getMessage());\n\n        MessageResponsePacket messageResponsePacket = new MessageResponsePacket();\n        messageResponsePacket.setMessage("服务端回复【" + messageRequestPacket.getMessage() + "】");\n        ByteBuf responseByteBuf = PacketCodeC.INSTANCE.encode(ctx.alloc(), messageResponsePacket);\n        ctx.channel().writeAndFlush(responseByteBuf);\n    }\n}\n\n')])])]),t("p",[e._v("服务端在收到消息之后，仍然是回调到 "),t("code",[e._v("channelRead()")]),e._v(" 方法，解码之后用一个 "),t("code",[e._v("else")]),e._v(" 分支进入消息处理的流程。")]),e._v(" "),t("p",[e._v("首先，服务端将收到的消息打印到控制台，然后封装一个消息响应对象 "),t("code",[e._v("MessageResponsePacket")]),e._v("，接下来还是老样子，先编码成 "),t("code",[e._v("ByteBuf")]),e._v("，然后调用 "),t("code",[e._v("writeAndFlush()")]),e._v(" 将数据写到客户端，最后，我们再来看一下客户端收到消息的逻辑。")]),e._v(" "),t("h2",{attrs:{id:"客户端收消息处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端收消息处理"}},[e._v("#")]),e._v(" 客户端收消息处理")]),e._v(" "),t("blockquote",[t("p",[e._v("ClientHandler.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void channelRead(ChannelHandlerContext ctx, Object msg) {\n    ByteBuf byteBuf = (ByteBuf) msg;\n\n    Packet packet = PacketCodeC.INSTANCE.decode(byteBuf);\n\n    if (packet instanceof LoginResponsePacket) {\n        // 登录逻辑...\n    } else if (packet instanceof MessageResponsePacket) {\n        MessageResponsePacket messageResponsePacket = (MessageResponsePacket) packet;\n        System.out.println(new Date() + ": 收到服务端的消息: " + messageResponsePacket.getMessage());\n    }\n}\n\n')])])]),t("p",[e._v("客户端在收到消息之后，回调到 "),t("code",[e._v("channelRead()")]),e._v(" 方法，仍然用一个 "),t("code",[e._v("else")]),e._v(" 逻辑进入到消息处理的逻辑，这里我们仅仅是简单地打印出消息，最后，我们再来看一下服务端和客户端的运行效果")]),e._v(" "),t("blockquote",[t("p",[e._v("完整的代码参考 "),t("a",{attrs:{href:"https://github.com/lightningMan/flash-netty/tree/%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8E%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%94%B6%E5%8F%91%E6%B6%88%E6%81%AF",target:"_blank",rel:"noopener noreferrer"}},[e._v("github"),t("OutboundLink")],1),e._v(", 分别启动 "),t("code",[e._v("NettyServer.java")]),e._v(" 与 "),t("code",[e._v("NettyClient.java")]),e._v(" 即可看到效果。")])]),e._v(" "),t("h2",{attrs:{id:"控制台输出"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#控制台输出"}},[e._v("#")]),e._v(" 控制台输出")]),e._v(" "),t("blockquote",[t("p",[e._v("客户端")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/15/1653af2fb9fb346d?w=1240&h=413&f=png&s=281289",alt:"image.png"}})]),e._v(" "),t("blockquote",[t("p",[e._v("服务端")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/15/1653af2fba0b762a?w=1240&h=308&f=png&s=224335",alt:"image.png"}})]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("p",[e._v("在本小节中")]),e._v(" "),t("ol",[t("li",[e._v("我们定义了收发消息的 Java 对象进行消息的收发。")]),e._v(" "),t("li",[e._v("然后我们学到了 channel 的 "),t("code",[e._v("attr()")]),e._v(" 的实际用法：可以通过给 channel 绑定属性来设置某些状态，获取某些状态，不需要额外的 map 来维持。")]),e._v(" "),t("li",[e._v("接着，我们学习了如何在控制台获取消息并且发送至服务端。")]),e._v(" "),t("li",[e._v("最后，我们实现了服务端回消息，客户端响应的逻辑，可以看到，这里的部分实际上和前面一小节的登录流程有点类似。")])]),e._v(" "),t("h2",{attrs:{id:"思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[e._v("#")]),e._v(" 思考")]),e._v(" "),t("p",[e._v("随着我们实现的指令越来越多，如何避免 "),t("code",[e._v("channelRead()")]),e._v(" 中对指令处理的 "),t("code",[e._v("if else")]),e._v(" 泛滥？欢迎留言讨论。")])])}),[],!1,null,null,null);t.default=s.exports}}]);