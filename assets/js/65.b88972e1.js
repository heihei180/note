(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{568:function(e,a,t){"use strict";t.r(a);var s=t(27),u=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"rebalancelockmanager"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebalancelockmanager"}},[e._v("#")]),e._v(" RebalanceLockManager")]),e._v(" "),a("p",[e._v("重平衡的锁管理对象，在rocketMQ会进行锁的重平衡，内部通过"),a("code",[e._v("mqLockTable")]),e._v(" 持有客户端以及messageQueue和ConsumerGroup的绑定关系")]),e._v(" "),a("h2",{attrs:{id:"什么是重平衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是重平衡"}},[e._v("#")]),e._v(" 什么是重平衡")]),e._v(" "),a("p",[e._v("当一个新的消费者客户端添加进来的时候，就需要进行MessageQueue 与 consumerClient之间的绑定关系的重平衡。")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/gq2/img_repo2/raw/master/img/image-20240126221630296.png",alt:"image-20240126221630296"}})]),e._v(" "),a("h2",{attrs:{id:"绑定关系解释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#绑定关系解释"}},[e._v("#")]),e._v(" 绑定关系解释")]),e._v(" "),a("p",[e._v("在rocketMQ中，为了提高性能，会将消息写到多个MessageQueue中，而消费者又从MessageQueue中拉取数据，每个MessageQueue最多绑定一个消费者客户端，因此，需要在内存中维护这样一份绑定关系。")]),e._v(" "),a("ol",[a("li",[e._v("首先是通过消费者组来区分，因为在rocketMq中，每个消费者组是互相隔离的，意思就是他们之间的消费关系是不一样的。")]),e._v(" "),a("li",[e._v("第二就是一个消费者组下面可以有多个消息队列messageQueue对象，")]),e._v(" "),a("li",[e._v("第三就是一个消息队列messageQueue可以单独绑定一个消费者，这里以id作为唯一标志。")])]),e._v(" "),a("h2",{attrs:{id:"如何绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何绑定"}},[e._v("#")]),e._v(" 如何绑定")]),e._v(" "),a("ol",[a("li",[e._v("首先判断给定的messageQueue是否已经绑定了消费者客户端，如果绑定了消费者，那么这个queue就不会在去绑定新的消费者客户端，"),a("strong",[e._v("即一个queu只允许一个消费者来消费")]),e._v("，这也是顺序消费的保证前提之一，单个queue的顺序性。")]),e._v(" "),a("li",[e._v("如果找到了有queue没有绑定消费者，那么就需要为这些queue绑定当前的客户端，以便于可以继续消费，下面解释如何进行绑定。\n"),a("ol",[a("li",[e._v("前提：对于没有绑定消费者的queue进行绑定，已经有消费者消费的queue不会在次绑定。")]),e._v(" "),a("li",[e._v("根据consumerGroup获取queue之间的绑定关系"),a("code",[e._v("ConcurrentHashMap<MessageQueue, LockEntry>")]),e._v("，根据数据结构看到是一对一的关系。")]),e._v(" "),a("li",[e._v("查找当前queue的锁对象lockEntity")]),e._v(" "),a("li",[e._v("为空的话，证明当前queue没有绑定消费者，需要创建锁对象，将消费者和queue之间的关系进行绑定。即构建map键值对。")]),e._v(" "),a("li",[e._v("为绑定关系对象"),a("code",[e._v("LockEntity")]),e._v(" 设置绑定时间，为当前时间。")])])])]),e._v(" "),a("h2",{attrs:{id:"如何解除绑定关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何解除绑定关系"}},[e._v("#")]),e._v(" 如何解除绑定关系")]),e._v(" "),a("p",[e._v("将上面绑定关系倒着来，")]),e._v(" "),a("ol",[a("li",[e._v("先根据消费者组找到queue和客户端的绑定映射，")]),e._v(" "),a("li",[e._v("将映射接触，即将map中的key"),a("code",[e._v("queue")]),e._v(" 移除，那么他们之间的绑定关系也就被删除了。")])])])}),[],!1,null,null,null);a.default=u.exports}}]);