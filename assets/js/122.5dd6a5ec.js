(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{434:function(t,e,o){"use strict";o.r(e);var r=o(25),i=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"nioeventloopgroup-分析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nioeventloopgroup-分析"}},[t._v("#")]),t._v(" NioEventLoopGroup 分析")]),t._v(" "),e("p",[t._v("**EventLoopGroup **本质上其实就是一个线程池，而我们常用的就是 **NioEventLoopGroup **，因此我们再这里来阅读一下 ** NioEventLoopGroup **")]),t._v(" "),e("h4",{attrs:{id:"nioeventloopgroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nioeventloopgroup"}},[t._v("#")]),t._v(" **NioEventLoopGroup **")]),t._v(" "),e("p",[t._v("先看类的继承关系图：\n"),e("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2022/png/2456646/1649656367340-47e48b35-e517-4f80-89b7-4bcb4b40ad80.png#clientId=u606126b8-8fb9-4&from=paste&height=666&id=u5eda0d38&originHeight=833&originWidth=655&originalType=binary&ratio=1&rotation=0&showTitle=false&size=53888&status=done&style=stroke&taskId=u115a0b3f-8e16-4186-aebf-4f9f2e0ec62&title=&width=524",alt:"image.png"}})]),t._v(" "),e("ul",[e("li",[t._v("可键 NioEventLoopGroup 继承了 **MultithreadEventLoopGroup **,")])]),t._v(" "),e("blockquote",[e("p",[t._v("MultithreadEventLoopGroup 理论说会实现很多通用的操作，但是再这里我们大概只看到他定义了一个默认的属性，就是线程数量，默认取CPU核心数的2倍")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("MultithreadEventLoopGroup 又继承自：MultithreadEventExecutorGroup")])]),t._v(" "),e("li",[e("p",[t._v("MultithreadEventExecutorGroup 继承自： AbstractEventExecutorGroup")])]),t._v(" "),e("li",[e("p",[t._v("AbstractEventExecutorGroup 实现了接口： EventExecutorGroup")])]),t._v(" "),e("li",[e("p",[t._v("接口定义：")]),t._v(" "),e("ul",[e("li",[t._v("EventExecutorGroup 接口继承了接口：ScheduledExecutorService、Iterable")]),t._v(" "),e("li",[t._v("ScheduledExecutorService：是Java util 下的线程池的包 、 继承了ExecutorService")]),t._v(" "),e("li",[t._v("ExecutorService 继承了Executor")])])])])])}),[],!1,null,null,null);e.default=i.exports}}]);