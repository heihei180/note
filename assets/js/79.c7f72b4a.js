(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{393:function(a,t,s){"use strict";s.r(t);var e=s(25),n=Object(e.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"_5-启动skywalking-服务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-启动skywalking-服务"}},[a._v("#")]),a._v(" 5. 启动SkyWalking 服务")]),a._v(" "),t("p",[a._v("上一节，将所有的插件如何激活，如何增强Java类，都已经介绍，，\n这里来介绍，如何启动skyWaling的服务.")]),a._v(" "),t("h2",{attrs:{id:"_5-1-sw-内部服务插件-bootservice"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-sw-内部服务插件-bootservice"}},[a._v("#")]),a._v(" 5.1 sw 内部服务插件 BootService")]),a._v(" "),t("h3",{attrs:{id:"_5-1-1-sw-服务的解释"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-1-sw-服务的解释"}},[a._v("#")]),a._v(" 5.1.1 sw 服务的解释")]),a._v(" "),t("p",[a._v("再sw中，比如想要发送 指标信息给oap，发送trace信息给Oap，就是使用了这个机制，创建一个服务对象，然后实现自己的逻辑。\n比如 发送jvm的指标信息，就说通过插件 "),t("code",[a._v("JVMMetricsSender")]),a._v(" 实现的， 这个插件默认使用 grpc 协议发送数据给OAP。\n当然他还有个实现类 "),t("code",[a._v("KafkaJVMMetricsSender")]),a._v(" ，他也是将 JVM 的指标信息发送给OAP，但是他使用的是kafka。")]),a._v(" "),t("h3",{attrs:{id:"_5-1-2-加载所有服务插件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-2-加载所有服务插件"}},[a._v("#")]),a._v(" 5.1.2 加载所有服务插件")]),a._v(" "),t("p",[a._v("SW 可以保证再所有插件都加载安装完成之后，查找并启动所有的服务对象。\n通过Java SPI 机制，加载所有 "),t("code",[a._v("BootService")]),a._v(" 接口的实现类")]),a._v(" "),t("p",[a._v("需要注意的是，大部分的服务接口都标注了注解："),t("code",[a._v("@DefaultImplementor")]),a._v(" 或者 "),t("code",[a._v("@OverrideImplementor")])]),a._v(" "),t("p",[a._v("如何理解这两个注解？")]),a._v(" "),t("ul",[t("li",[a._v("DefaultImplementor 默认实现类")]),a._v(" "),t("li",[a._v("OverrideImplementor 重写实现类")])]),a._v(" "),t("p",[a._v("用上面说到的 "),t("code",[a._v("JVMMetricsSender")]),a._v(" 为例，他有两个实现类，一个是 "),t("code",[a._v("JVMMetricsSender")]),a._v(" 一个是 "),t("code",[a._v("KafkaJVMMetricsSender")]),a._v("，")]),a._v(" "),t("p",[a._v("sw 在初期版本，所有的内部组件通讯协议都是GRPC，所以，发送JVM指标信息的实现也是使用GRPC协议来发送的，也就是说 "),t("code",[a._v("JVMMetricsSender")]),a._v(" 的功能，\n他标注了注解 "),t("code",[a._v("@DefaultImplementor")]),a._v("，声明这种方式是传输指标的默认方式。")]),a._v(" "),t("p",[a._v("后期，可能有一些较大发服务集群，GRPC可能吞吐率或者其他方面无法达到要求，可以选择Kafka来发送指标信息，这个时候就可以使用 "),t("code",[a._v("KafkaJVMMetricsSender")]),a._v("，\n但是也不可以直接修改原始的代码，所以，可以新建一个"),t("code",[a._v("BootService")]),a._v(" 的实现类，使用 "),t("code",[a._v("@OverrideImplementor")]),a._v(" 来标注这个实现类，声明这个实现类用于覆盖默认实现。")]),a._v(" "),t("p",[a._v("如：")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@DefaultImplementor")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JVMMetricsSender")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("BootService")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Runnable")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("GRPCChannelListener")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...  使用grpc 发送消息的具体实现")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n\n"),t("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@OverrideImplementor")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JVMMetricsSender")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("KafkaJVMMetricsSender")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("JVMMetricsSender")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("KafkaConnectionStatusListener")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ... 使用kafka 发送消息的具体实现")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),t("p",[a._v("由上面代码看到，OverrideImplementor 标注了要覆盖 "),t("code",[a._v("JVMMetricsSender")]),a._v(" 。")]),a._v(" "),t("h3",{attrs:{id:"_5-2-服务的生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-服务的生命周期"}},[a._v("#")]),a._v(" 5.2 服务的生命周期")]),a._v(" "),t("p",[a._v("在sw内部的服务，有一个生命周期，或者说类似于模板设计模式。")]),a._v(" "),t("div",{staticClass:"language-java extra-class"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[a._v("   "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("prepare")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("startup")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ==>  boot(); 对应服务的boot函数")]),a._v("\n   "),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("onComplete")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),t("p",[a._v("SW 会在加载到所有的服务之后，按照顺序，分别再去调用单独每个服务的这三个函数。")]),a._v(" "),t("p",[a._v("因此，可以理解为生命周期吧，分别是 准备阶段， 启动阶段， 完成阶段。")]),a._v(" "),t("p",[a._v("当然，sw会在服务结束时，调用服务的 "),t("code",[a._v("shutdown()")]),a._v(" 函数。意味销毁的回调函数，可以用于关闭链接，释放资源等。")]),a._v(" "),t("p",[t("strong",[a._v("举个例子")]),a._v(" "),t("code",[a._v("KafkaJVMMetricsSender")]),a._v(" 在 "),t("code",[a._v("prepare()")]),a._v(" 阶段，初始化花村队列，用于存放agent收集到的消息，")]),a._v(" "),t("p",[t("code",[a._v("KafkaProducerManager")]),a._v(" 在 "),t("code",[a._v("boot")]),a._v(" 阶段，链接kafka，"),t("code",[a._v("shutdown()")]),a._v(" 阶段，关闭kafka链接。")])])}),[],!1,null,null,null);t.default=n.exports}}]);