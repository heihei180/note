(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{339:function(e,t,n){"use strict";n.r(t);var r=n(25),a=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"netty-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty-是什么"}},[e._v("#")]),e._v(" Netty 是什么？")]),e._v(" "),t("p",[e._v("在开始了解 Netty 是什么之前，我们先来回顾一下，如果我们需要实现一个客户端与服务端通信的程序，使用传统的 IO 编程，应该如何来实现？")]),e._v(" "),t("h2",{attrs:{id:"io编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io编程"}},[e._v("#")]),e._v(" IO编程")]),e._v(" "),t("p",[e._v('我们简化下场景：客户端每隔两秒发送一个带有时间戳的 "hello world" 给服务端，服务端收到之后打印。')]),e._v(" "),t("p",[e._v("为了方便演示，下面例子中，服务端和客户端各一个类，把这两个类拷贝到你的 IDE 中，先后运行 "),t("code",[e._v("IOServer.java")]),e._v(" 和"),t("code",[e._v("IOClient.java")]),e._v("可看到效果。")]),e._v(" "),t("p",[e._v("下面是传统的 IO 编程中服务端实现")]),e._v(" "),t("blockquote",[t("p",[e._v("IOServer.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * @author 闪电侠\n */\npublic class IOServer {\n    public static void main(String[] args) throws Exception {\n\n        ServerSocket serverSocket = new ServerSocket(8000);\n\n        // (1) 接收新连接线程\n        new Thread(() -> {\n            while (true) {\n                try {\n                    // (1) 阻塞方法获取新的连接\n                    Socket socket = serverSocket.accept();\n\n                    // (2) 每一个新的连接都创建一个线程，负责读取数据\n                    new Thread(() -> {\n                        try {\n                            int len;\n                            byte[] data = new byte[1024];\n                            InputStream inputStream = socket.getInputStream();\n                            // (3) 按字节流方式读取数据\n                            while ((len = inputStream.read(data)) != -1) {\n                                System.out.println(new String(data, 0, len));\n                            }\n                        } catch (IOException e) {\n                        }\n                    }).start();\n\n                } catch (IOException e) {\n                }\n\n            }\n        }).start();\n    }\n}\n\n")])])]),t("p",[e._v("Server 端首先创建了一个"),t("code",[e._v("serverSocket")]),e._v("来监听 8000 端口，然后创建一个线程，线程里面不断调用阻塞方法 "),t("code",[e._v("serversocket.accept();")]),e._v("获取新的连接，见(1)，当获取到新的连接之后，给每条连接创建一个新的线程，这个线程负责从该连接中读取数据，见(2)，然后读取数据是以字节流的方式，见(3)。")]),e._v(" "),t("p",[e._v("下面是传统的IO编程中客户端实现")]),e._v(" "),t("blockquote",[t("p",[e._v("IOClient.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n * @author 闪电侠\n */\npublic class IOClient {\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            try {\n                Socket socket = new Socket("127.0.0.1", 8000);\n                while (true) {\n                    try {\n                        socket.getOutputStream().write((new Date() + ": hello world").getBytes());\n                        Thread.sleep(2000);\n                    } catch (Exception e) {\n                    }\n                }\n            } catch (IOException e) {\n            }\n        }).start();\n    }\n}\n\n')])])]),t("p",[e._v('客户端的代码相对简单，连接上服务端 8000 端口之后，每隔 2 秒，我们向服务端写一个带有时间戳的 "hello world"。')]),e._v(" "),t("p",[e._v("IO 编程模型在客户端较少的情况下运行良好，但是对于客户端比较多的业务来说，单机服务端可能需要支撑成千上万的连接，IO 模型可能就不太合适了，我们来分析一下原因。")]),e._v(" "),t("p",[e._v("上面的 demo，从服务端代码中我们可以看到，在传统的 IO 模型中，每个连接创建成功之后都需要一个线程来维护，每个线程包含一个 while 死循环，那么 1w 个连接对应 1w 个线程，继而 1w 个 while 死循环，这就带来如下几个问题：")]),e._v(" "),t("ol",[t("li",[e._v("线程资源受限：线程是操作系统中非常宝贵的资源，同一时刻有大量的线程处于阻塞状态是非常严重的资源浪费，操作系统耗不起")]),e._v(" "),t("li",[e._v("线程切换效率低下：单机 CPU 核数固定，线程爆炸之后操作系统频繁进行线程切换，应用性能急剧下降。")]),e._v(" "),t("li",[e._v("除了以上两个问题，IO 编程中，我们看到数据读写是以字节流为单位。")])]),e._v(" "),t("p",[e._v("为了解决这三个问题，JDK 在 1.4 之后提出了 NIO。")]),e._v(" "),t("h2",{attrs:{id:"nio-编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#nio-编程"}},[e._v("#")]),e._v(" NIO 编程")]),e._v(" "),t("p",[e._v("关于 NIO 相关的文章网上也有很多，这里不打算详细深入分析，下面简单描述一下 NIO 是如何解决以上三个问题的。")]),e._v(" "),t("h3",{attrs:{id:"线程资源受限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程资源受限"}},[e._v("#")]),e._v(" 线程资源受限")]),e._v(" "),t("p",[e._v("NIO 编程模型中，新来一个连接不再创建一个新的线程，而是可以把这条连接直接绑定到某个固定的线程，然后这条连接所有的读写都由这个线程来负责，那么他是怎么做到的？我们用一幅图来对比一下 IO 与 NIO")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/7/16/164a0874b7ccd652?w=755&h=788&f=png&s=41868",alt:"image.png"}})]),e._v(" "),t("p",[e._v("如上图所示，IO 模型中，一个连接来了，会创建一个线程，对应一个 while 死循环，死循环的目的就是不断监测这条连接上是否有数据可以读，大多数情况下，1w 个连接里面同一时刻只有少量的连接有数据可读，因此，很多个 while 死循环都白白浪费掉了，因为读不出啥数据。")]),e._v(" "),t("p",[e._v("而在 NIO 模型中，他把这么多 while 死循环变成一个死循环，这个死循环由一个线程控制，那么他又是如何做到一个线程，一个 while 死循环就能监测1w个连接是否有数据可读的呢？ 这就是 NIO 模型中 selector 的作用，一条连接来了之后，现在不创建一个 while 死循环去监听是否有数据可读了，而是直接把这条连接注册到 selector 上，然后，通过检查这个 selector，就可以批量监测出有数据可读的连接，进而读取数据，下面我再举个非常简单的生活中的例子说明 IO 与 NIO 的区别。")]),e._v(" "),t("p",[e._v("在一家幼儿园里，小朋友有上厕所的需求，小朋友都太小以至于你要问他要不要上厕所，他才会告诉你。幼儿园一共有 100 个小朋友，有两种方案可以解决小朋友上厕所的问题：")]),e._v(" "),t("ol",[t("li",[e._v("每个小朋友配一个老师。每个老师隔段时间询问小朋友是否要上厕所，如果要上，就领他去厕所，100 个小朋友就需要 100 个老师来询问，并且每个小朋友上厕所的时候都需要一个老师领着他去上，这就是IO模型，一个连接对应一个线程。")]),e._v(" "),t("li",[e._v("所有的小朋友都配同一个老师。这个老师隔段时间询问所有的小朋友是否有人要上厕所，然后每一时刻把所有要上厕所的小朋友批量领到厕所，这就是 NIO 模型，所有小朋友都注册到同一个老师，对应的就是所有的连接都注册到一个线程，然后批量轮询。")])]),e._v(" "),t("p",[e._v("这就是 NIO 模型解决线程资源受限的方案，实际开发过程中，我们会开多个线程，每个线程都管理着一批连接，相对于 IO 模型中一个线程管理一条连接，消耗的线程资源大幅减少")]),e._v(" "),t("h3",{attrs:{id:"线程切换效率低下"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程切换效率低下"}},[e._v("#")]),e._v(" 线程切换效率低下")]),e._v(" "),t("p",[e._v("由于 NIO 模型中线程数量大大降低，线程切换效率因此也大幅度提高")]),e._v(" "),t("h3",{attrs:{id:"io读写面向流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#io读写面向流"}},[e._v("#")]),e._v(" IO读写面向流")]),e._v(" "),t("p",[e._v("IO 读写是面向流的，一次性只能从流中读取一个或者多个字节，并且读完之后流无法再读取，你需要自己缓存数据。 而 NIO 的读写是面向 Buffer 的，你可以随意读取里面任何一个字节数据，不需要你自己缓存数据，这一切只需要移动读写指针即可。")]),e._v(" "),t("p",[e._v("简单讲完了 JDK NIO 的解决方案之后，我们接下来使用 NIO 的方案替换掉 IO 的方案，我们先来看看，如果用 JDK 原生的 NIO 来实现服务端，该怎么做")]),e._v(" "),t("blockquote",[t("p",[e._v("前方高能预警：以下代码可能会让你感觉极度不适，如有不适，请跳过")])]),e._v(" "),t("blockquote",[t("p",[e._v("NIOServer.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * @author 闪电侠\n */\npublic class NIOServer {\n    public static void main(String[] args) throws IOException {\n        Selector serverSelector = Selector.open();\n        Selector clientSelector = Selector.open();\n\n        new Thread(() -> {\n            try {\n                // 对应IO编程中服务端启动\n                ServerSocketChannel listenerChannel = ServerSocketChannel.open();\n                listenerChannel.socket().bind(new InetSocketAddress(8000));\n                listenerChannel.configureBlocking(false);\n                listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);\n\n                while (true) {\n                    // 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms\n                    if (serverSelector.select(1) > 0) {\n                        Set<SelectionKey> set = serverSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n\n                            if (key.isAcceptable()) {\n                                try {\n                                    // (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector\n                                    SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();\n                                    clientChannel.configureBlocking(false);\n                                    clientChannel.register(clientSelector, SelectionKey.OP_READ);\n                                } finally {\n                                    keyIterator.remove();\n                                }\n                            }\n\n                        }\n                    }\n                }\n            } catch (IOException ignored) {\n            }\n\n        }).start();\n\n\n        new Thread(() -> {\n            try {\n                while (true) {\n                    // (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms\n                    if (clientSelector.select(1) > 0) {\n                        Set<SelectionKey> set = clientSelector.selectedKeys();\n                        Iterator<SelectionKey> keyIterator = set.iterator();\n\n                        while (keyIterator.hasNext()) {\n                            SelectionKey key = keyIterator.next();\n\n                            if (key.isReadable()) {\n                                try {\n                                    SocketChannel clientChannel = (SocketChannel) key.channel();\n                                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);\n                                    // (3) 面向 Buffer\n                                    clientChannel.read(byteBuffer);\n                                    byteBuffer.flip();\n                                    System.out.println(Charset.defaultCharset().newDecoder().decode(byteBuffer)\n                                            .toString());\n                                } finally {\n                                    keyIterator.remove();\n                                    key.interestOps(SelectionKey.OP_READ);\n                                }\n                            }\n\n                        }\n                    }\n                }\n            } catch (IOException ignored) {\n            }\n        }).start();\n\n\n    }\n}\n\n")])])]),t("p",[e._v("相信大部分没有接触过 NIO 的同学应该会直接跳过代码来到这一行：原来使用 JDK 原生 NIO 的 API 实现一个简单的服务端通信程序是如此复杂!")]),e._v(" "),t("p",[e._v("复杂得我都没耐心解释这一坨代码的执行逻辑(开个玩笑)，我们还是先对照 NIO 来解释一下几个核心思路")]),e._v(" "),t("ol",[t("li",[e._v("NIO 模型中通常会有两个线程，每个线程绑定一个轮询器 selector ，在我们这个例子中"),t("code",[e._v("serverSelector")]),e._v("负责轮询是否有新的连接，"),t("code",[e._v("clientSelector")]),e._v("负责轮询连接是否有数据可读")]),e._v(" "),t("li",[e._v("服务端监测到新的连接之后，不再创建一个新的线程，而是直接将新连接绑定到"),t("code",[e._v("clientSelector")]),e._v("上，这样就不用 IO 模型中 1w 个 while 循环在死等，参见(1)")]),e._v(" "),t("li",[t("code",[e._v("clientSelector")]),e._v("被一个 while 死循环包裹着，如果在某一时刻有多条连接有数据可读，那么通过 "),t("code",[e._v("clientSelector.select(1)")]),e._v("方法可以轮询出来，进而批量处理，参见(2)")]),e._v(" "),t("li",[e._v("数据的读写面向 Buffer，参见(3)")])]),e._v(" "),t("p",[e._v("其他的细节部分，我不愿意多讲，因为实在是太复杂，你也不用对代码的细节深究到底。总之，强烈不建议直接基于JDK原生NIO来进行网络开发，下面是我总结的原因")]),e._v(" "),t("ol",[t("li",[e._v("JDK 的 NIO 编程需要了解很多的概念，编程复杂，对 NIO 入门非常不友好，编程模型不友好，ByteBuffer 的 Api 简直反人类")]),e._v(" "),t("li",[e._v("对 NIO 编程来说，一个比较合适的线程模型能充分发挥它的优势，而 JDK 没有给你实现，你需要自己实现，就连简单的自定义协议拆包都要你自己实现")]),e._v(" "),t("li",[e._v("JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%")]),e._v(" "),t("li",[e._v("项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug")])]),e._v(" "),t("p",[e._v("正因为如此，我客户端代码都懒得写给你看了==!，你可以直接使用"),t("code",[e._v("IOClient.java")]),e._v("与"),t("code",[e._v("NIOServer.java")]),e._v("通信")]),e._v(" "),t("p",[e._v("JDK 的 NIO 犹如带刺的玫瑰，虽然美好，让人向往，但是使用不当会让你抓耳挠腮，痛不欲生，正因为如此，Netty 横空出世！")]),e._v(" "),t("h2",{attrs:{id:"netty编程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#netty编程"}},[e._v("#")]),e._v(" Netty编程")]),e._v(" "),t("p",[e._v("那么 Netty 到底是何方神圣？ 用一句简单的话来说就是：Netty 封装了 JDK 的 NIO，让你用得更爽，你不用再写一大堆复杂的代码了。 用官方正式的话来说就是：Netty 是一个异步事件驱动的网络应用框架，用于快速开发可维护的高性能服务器和客户端。")]),e._v(" "),t("p",[e._v("下面是我总结的使用 Netty 不使用 JDK 原生 NIO 的原因")]),e._v(" "),t("ol",[t("li",[e._v("使用 JDK 自带的NIO需要了解太多的概念，编程复杂，一不小心 bug 横飞")]),e._v(" "),t("li",[e._v("Netty 底层 IO 模型随意切换，而这一切只需要做微小的改动，改改参数，Netty可以直接从 NIO 模型变身为 IO 模型")]),e._v(" "),t("li",[e._v("Netty 自带的拆包解包，异常检测等机制让你从NIO的繁重细节中脱离出来，让你只需要关心业务逻辑")]),e._v(" "),t("li",[e._v("Netty 解决了 JDK 的很多包括空轮询在内的 Bug")]),e._v(" "),t("li",[e._v("Netty 底层对线程，selector 做了很多细小的优化，精心设计的 reactor 线程模型做到非常高效的并发处理")]),e._v(" "),t("li",[e._v("自带各种协议栈让你处理任何一种通用协议都几乎不用亲自动手")]),e._v(" "),t("li",[e._v("Netty 社区活跃，遇到问题随时邮件列表或者 issue")]),e._v(" "),t("li",[e._v("Netty 已经历各大 RPC 框架，消息中间件，分布式通信中间件线上的广泛验证，健壮性无比强大")])]),e._v(" "),t("p",[e._v("看不懂没有关系，这些我们在后续的课程中我们都可以学到，接下来我们用 Netty 的版本来重新实现一下本文开篇的功能吧")]),e._v(" "),t("p",[e._v("首先，引入 Maven 依赖，本文后续 Netty 都是基于 4.1.6.Final 版本")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("    <dependency>\n        <groupId>io.netty</groupId>\n        <artifactId>netty-all</artifactId>\n        <version>4.1.6.Final</version>\n    </dependency>\n\n")])])]),t("p",[e._v("然后，下面是服务端实现部分")]),e._v(" "),t("blockquote",[t("p",[e._v("NettyServer.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("/**\n * @author 闪电侠\n */\npublic class NettyServer {\n    public static void main(String[] args) {\n        ServerBootstrap serverBootstrap = new ServerBootstrap();\n\n        NioEventLoopGroup boss = new NioEventLoopGroup();\n        NioEventLoopGroup worker = new NioEventLoopGroup();\n        serverBootstrap\n                .group(boss, worker)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer<NioSocketChannel>() {\n                    protected void initChannel(NioSocketChannel ch) {\n                        ch.pipeline().addLast(new StringDecoder());\n                        ch.pipeline().addLast(new SimpleChannelInboundHandler<String>() {\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, String msg) {\n                                System.out.println(msg);\n                            }\n                        });\n                    }\n                })\n                .bind(8000);\n    }\n}\n\n\n")])])]),t("p",[e._v("这么一小段代码就实现了我们前面 NIO 编程中的所有的功能，包括服务端启动，接受新连接，打印客户端传来的数据，怎么样，是不是比 JDK 原生的 NIO 编程优雅许多？")]),e._v(" "),t("p",[e._v("初学 Netty 的时候，由于大部分人对 NIO 编程缺乏经验，因此，将 Netty 里面的概念与 IO 模型结合起来可能更好理解")]),e._v(" "),t("ol",[t("li",[t("code",[e._v("boss")]),e._v(" 对应 "),t("code",[e._v("IOServer.java")]),e._v(" 中的接受新连接线程，主要负责创建新连接")]),e._v(" "),t("li",[t("code",[e._v("worker")]),e._v(" 对应 "),t("code",[e._v("IOServer.java")]),e._v(" 中的负责读取数据的线程，主要用于读取数据以及业务逻辑处理")])]),e._v(" "),t("p",[e._v("然后剩下的逻辑我在后面的系列文章中会详细分析，你可以先把这段代码拷贝到你的 IDE 里面，然后运行 main 函数")]),e._v(" "),t("p",[e._v("然后下面是客户端 NIO 的实现部分")]),e._v(" "),t("blockquote",[t("p",[e._v("NettyClient.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('/**\n * @author 闪电侠\n */\npublic class NettyClient {\n    public static void main(String[] args) throws InterruptedException {\n        Bootstrap bootstrap = new Bootstrap();\n        NioEventLoopGroup group = new NioEventLoopGroup();\n\n        bootstrap.group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer<Channel>() {\n                    @Override\n                    protected void initChannel(Channel ch) {\n                        ch.pipeline().addLast(new StringEncoder());\n                    }\n                });\n\n        Channel channel = bootstrap.connect("127.0.0.1", 8000).channel();\n\n        while (true) {\n            channel.writeAndFlush(new Date() + ": hello world!");\n            Thread.sleep(2000);\n        }\n    }\n}\n\n')])])]),t("p",[e._v("在客户端程序中，"),t("code",[e._v("group")]),e._v("对应了我们"),t("code",[e._v("IOClient.java")]),e._v("中 main 函数起的线程，剩下的逻辑我在后面的文章中会详细分析，现在你要做的事情就是把这段代码拷贝到你的 IDE 里面，然后运行 main 函数，最后回到 "),t("code",[e._v("NettyServer.java")]),e._v(" 的控制台，你会看到效果。")]),e._v(" "),t("p",[e._v("使用 Netty 之后是不是觉得整个世界都美好了，一方面 Netty 对 NIO 封装得如此完美，写出来的代码非常优雅，另外一方面，使用 Netty 之后，网络通信这块的性能问题几乎不用操心，尽情地让 Netty 榨干你的 CPU 吧。")])])}),[],!1,null,null,null);t.default=a.exports}}]);