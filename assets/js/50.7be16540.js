(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{553:function(e,t,a){"use strict";a.r(t);var r=a(27),n=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"数据传输载体-bytebuf-介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据传输载体-bytebuf-介绍"}},[e._v("#")]),e._v(" 数据传输载体 ByteBuf 介绍")]),e._v(" "),t("p",[e._v("在前面一小节，我们已经了解到 Netty 里面数据读写是以 ByteBuf 为单位进行交互的，这一小节，我们就来详细剖析一下 ByteBuf")]),e._v(" "),t("h2",{attrs:{id:"bytebuf结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bytebuf结构"}},[e._v("#")]),e._v(" ByteBuf结构")]),e._v(" "),t("p",[e._v("首先，我们先来了解一下 ByteBuf 的结构")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://user-gold-cdn.xitu.io/2018/8/5/1650817a1455afbb?w=1240&h=539&f=png&s=20890",alt:"image.png"}})]),e._v(" "),t("p",[e._v("以上就是一个 ByteBuf 的结构图，从上面这幅图可以看到")]),e._v(" "),t("ol",[t("li",[e._v("ByteBuf 是一个字节容器，容器里面的的数据分为三个部分，第一个部分是已经丢弃的字节，这部分数据是无效的；第二部分是可读字节，这部分数据是 ByteBuf 的主体数据， 从 ByteBuf 里面读取的数据都来自这一部分;最后一部分的数据是可写字节，所有写到 ByteBuf 的数据都会写到这一段。最后一部分虚线表示的是该 ByteBuf 最多还能扩容多少容量")]),e._v(" "),t("li",[e._v("以上三段内容是被两个指针给划分出来的，从左到右，依次是读指针（readerIndex）、写指针（writerIndex），然后还有一个变量 capacity，表示 ByteBuf 底层内存的总容量")]),e._v(" "),t("li",[e._v("从 ByteBuf 中每读取一个字节，readerIndex 自增1，ByteBuf 里面总共有 writerIndex-readerIndex 个字节可读, 由此可以推论出当 readerIndex 与 writerIndex 相等的时候，ByteBuf 不可读")]),e._v(" "),t("li",[e._v("写数据是从 writerIndex 指向的部分开始写，每写一个字节，writerIndex 自增1，直到增到 capacity，这个时候，表示 ByteBuf 已经不可写了")]),e._v(" "),t("li",[e._v("ByteBuf 里面其实还有一个参数 maxCapacity，当向 ByteBuf 写数据的时候，如果容量不足，那么这个时候可以进行扩容，直到 capacity 扩容到 maxCapacity，超过 maxCapacity 就会报错")])]),e._v(" "),t("p",[e._v("Netty 使用 ByteBuf 这个数据结构可以有效地区分可读数据和可写数据，读写之间相互没有冲突，当然，ByteBuf 只是对二进制数据的抽象，具体底层的实现我们在下面的小节会讲到，在这一小节，我们 只需要知道 Netty 关于数据读写只认 ByteBuf，下面，我们就来学习一下 ByteBuf 常用的 API")]),e._v(" "),t("h2",{attrs:{id:"容量-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#容量-api"}},[e._v("#")]),e._v(" 容量 API")]),e._v(" "),t("blockquote",[t("p",[e._v("capacity()")])]),e._v(" "),t("p",[e._v("表示 ByteBuf 底层占用了多少字节的内存（包括丢弃的字节、可读字节、可写字节），不同的底层实现机制有不同的计算方式，后面我们讲 ByteBuf 的分类的时候会讲到")]),e._v(" "),t("blockquote",[t("p",[e._v("maxCapacity()")])]),e._v(" "),t("p",[e._v("表示 ByteBuf 底层最大能够占用多少字节的内存，当向 ByteBuf 中写数据的时候，如果发现容量不足，则进行扩容，直到扩容到 maxCapacity，超过这个数，就抛异常")]),e._v(" "),t("blockquote",[t("p",[e._v("readableBytes() 与 isReadable()")])]),e._v(" "),t("p",[e._v("readableBytes() 表示 ByteBuf 当前可读的字节数，它的值等于 writerIndex-readerIndex，如果两者相等，则不可读，isReadable() 方法返回 false")]),e._v(" "),t("blockquote",[t("p",[e._v("writableBytes()、 isWritable() 与 maxWritableBytes()")])]),e._v(" "),t("p",[e._v("writableBytes() 表示 ByteBuf 当前可写的字节数，它的值等于 capacity-writerIndex，如果两者相等，则表示不可写，isWritable() 返回 false，但是这个时候，并不代表不能往 ByteBuf 中写数据了， 如果发现往 ByteBuf 中写数据写不进去的话，Netty 会自动扩容 ByteBuf，直到扩容到底层的内存大小为 maxCapacity，而 maxWritableBytes() 就表示可写的最大字节数，它的值等于 maxCapacity-writerIndex")]),e._v(" "),t("h2",{attrs:{id:"读写指针相关的-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读写指针相关的-api"}},[e._v("#")]),e._v(" 读写指针相关的 API")]),e._v(" "),t("blockquote",[t("p",[e._v("readerIndex() 与 readerIndex(int)")])]),e._v(" "),t("p",[e._v("前者表示返回当前的读指针 readerIndex, 后者表示设置读指针")]),e._v(" "),t("blockquote",[t("p",[e._v("writeIndex() 与 writeIndex(int)")])]),e._v(" "),t("p",[e._v("前者表示返回当前的写指针 writerIndex, 后者表示设置写指针")]),e._v(" "),t("blockquote",[t("p",[e._v("markReaderIndex() 与 resetReaderIndex()")])]),e._v(" "),t("p",[e._v("前者表示把当前的读指针保存起来，后者表示把当前的读指针恢复到之前保存的值，下面两段代码是等价的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 代码片段1\nint readerIndex = buffer.readerIndex();\n// .. 其他操作\nbuffer.readerIndex(readerIndex);\n\n\n// 代码片段二\nbuffer.markReaderIndex();\n// .. 其他操作\nbuffer.resetReaderIndex();\n\n")])])]),t("p",[e._v("希望大家多多使用代码片段二这种方式，不需要自己定义变量，无论 buffer 当作参数传递到哪里，调用 resetReaderIndex() 都可以恢复到之前的状态，在解析自定义协议的数据包的时候非常常见，推荐大家使用这一对 API")]),e._v(" "),t("blockquote",[t("p",[e._v("markWriterIndex() 与 resetWriterIndex()")])]),e._v(" "),t("p",[e._v("这一对 API 的作用与上述一对 API 类似，这里不再 赘述")]),e._v(" "),t("h2",{attrs:{id:"读写-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#读写-api"}},[e._v("#")]),e._v(" 读写 API")]),e._v(" "),t("p",[e._v("本质上，关于 ByteBuf 的读写都可以看作从指针开始的地方开始读写数据")]),e._v(" "),t("blockquote",[t("p",[e._v("writeBytes(byte[] src) 与 buffer.readBytes(byte[] dst)")])]),e._v(" "),t("p",[e._v("writeBytes() 表示把字节数组 src 里面的数据全部写到 ByteBuf，而 readBytes() 指的是把 ByteBuf 里面的数据全部读取到 dst，这里 dst 字节数组的大小通常等于 readableBytes()，而 src 字节数组大小的长度通常小于等于 writableBytes()")]),e._v(" "),t("blockquote",[t("p",[e._v("writeByte(byte b) 与 buffer.readByte()")])]),e._v(" "),t("p",[e._v("writeByte() 表示往 ByteBuf 中写一个字节，而 buffer.readByte() 表示从 ByteBuf 中读取一个字节，类似的 API 还有 writeBoolean()、writeChar()、writeShort()、writeInt()、writeLong()、writeFloat()、writeDouble() 与 readBoolean()、readChar()、readShort()、readInt()、readLong()、readFloat()、readDouble() 这里就不一一赘述了，相信读者应该很容易理解这些 API")]),e._v(" "),t("p",[e._v("与读写 API 类似的 API 还有 getBytes、getByte() 与 setBytes()、setByte() 系列，唯一的区别就是 get/set 不会改变读写指针，而 read/write 会改变读写指针，这点在解析数据的时候千万要注意")]),e._v(" "),t("blockquote",[t("p",[e._v("release() 与 retain()")])]),e._v(" "),t("p",[e._v("由于 Netty 使用了堆外内存，而堆外内存是不被 jvm 直接管理的，也就是说申请到的内存无法被垃圾回收器直接回收，所以需要我们手动回收。有点类似于c语言里面，申请到的内存必须手工释放，否则会造成内存泄漏。")]),e._v(" "),t("p",[e._v("Netty 的 ByteBuf 是通过引用计数的方式管理的，如果一个 ByteBuf 没有地方被引用到，需要回收底层内存。默认情况下，当创建完一个 ByteBuf，它的引用为1，然后每次调用 retain() 方法， 它的引用就加一， release() 方法原理是将引用计数减一，减完之后如果发现引用计数为0，则直接回收 ByteBuf 底层的内存。")]),e._v(" "),t("blockquote",[t("p",[e._v("slice()、duplicate()、copy()")])]),e._v(" "),t("p",[e._v("这三个方法通常情况会放到一起比较，这三者的返回值都是一个新的 ByteBuf 对象")]),e._v(" "),t("ol",[t("li",[e._v("slice() 方法从原始 ByteBuf 中截取一段，这段数据是从 readerIndex 到 writeIndex，同时，返回的新的 ByteBuf 的最大容量 maxCapacity 为原始 ByteBuf 的 readableBytes()")]),e._v(" "),t("li",[e._v("duplicate() 方法把整个 ByteBuf 都截取出来，包括所有的数据，指针信息")]),e._v(" "),t("li",[e._v("slice() 方法与 duplicate() 方法的相同点是：底层内存以及引用计数与原始的 ByteBuf 共享，也就是说经过 slice() 或者 duplicate() 返回的 ByteBuf 调用 write 系列方法都会影响到 原始的 ByteBuf，但是它们都维持着与原始 ByteBuf 相同的内存引用计数和不同的读写指针")]),e._v(" "),t("li",[e._v("slice() 方法与 duplicate() 不同点就是：slice() 只截取从 readerIndex 到 writerIndex 之间的数据，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整个 ByteBuf 都与原始的 ByteBuf 共享")]),e._v(" "),t("li",[e._v("slice() 方法与 duplicate() 方法不会拷贝数据，它们只是通过改变读写指针来改变读写的行为，而最后一个方法 copy() 会直接从原始的 ByteBuf 中拷贝所有的信息，包括读写指针以及底层对应的数据，因此，往 copy() 返回的 ByteBuf 中写数据不会影响到原始的 ByteBuf")]),e._v(" "),t("li",[e._v("slice() 和 duplicate() 不会改变 ByteBuf 的引用计数，所以原始的 ByteBuf 调用 release() 之后发现引用计数为零，就开始释放内存，调用这两个方法返回的 ByteBuf 也会被释放，这个时候如果再对它们进行读写，就会报错。因此，我们可以通过调用一次 retain() 方法 来增加引用，表示它们对应的底层的内存多了一次引用，引用计数为2，在释放内存的时候，需要调用两次 release() 方法，将引用计数降到零，才会释放内存")]),e._v(" "),t("li",[e._v("这三个方法均维护着自己的读写指针，与原始的 ByteBuf 的读写指针无关，相互之间不受影响")])]),e._v(" "),t("blockquote",[t("p",[e._v("retainedSlice() 与 retainedDuplicate()")])]),e._v(" "),t("p",[e._v("相信读者应该已经猜到这两个 API 的作用了，它们的作用是在截取内存片段的同时，增加内存的引用计数，分别与下面两段代码等价")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// retainedSlice 等价于\nslice().retain();\n\n// retainedDuplicate() 等价于\nduplicate().retain()\n\n")])])]),t("p",[e._v("使用到 slice 和 duplicate 方法的时候，千万要理清内存共享，引用计数共享，读写指针不共享几个概念，下面举两个常见的易犯错的例子")]),e._v(" "),t("ol",[t("li",[e._v("多次释放")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Buffer buffer = xxx;\ndoWith(buffer);\n// 一次释放\nbuffer.release();\n\n\npublic void doWith(Bytebuf buffer) {\n// ...    \n    \n// 没有增加引用计数\nBuffer slice = buffer.slice();\n\nfoo(slice);\n\n}\n\n\npublic void foo(ByteBuf buffer) {\n    // read from buffer\n    \n    // 重复释放\n    buffer.release();\n}\n\n")])])]),t("p",[e._v("这里的 doWith 有的时候是用户自定义的方法，有的时候是 Netty 的回调方法，比如 "),t("code",[e._v("channelRead()")]),e._v(" 等等")]),e._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[e._v("不释放造成内存泄漏")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Buffer buffer = xxx;\ndoWith(buffer);\n// 引用计数为2，调用 release 方法之后，引用计数为1，无法释放内存 \nbuffer.release();\n\n\npublic void doWith(Bytebuf buffer) {\n// ...    \n    \n// 增加引用计数\nBuffer slice = buffer.retainedSlice();\n\nfoo(slice);\n\n// 没有调用 release\n\n}\n\n\npublic void foo(ByteBuf buffer) {\n    // read from buffer\n}\n\n")])])]),t("p",[e._v("想要避免以上两种情况发生，大家只需要记得一点，在一个函数体里面，只要增加了引用计数（包括 ByteBuf 的创建和手动调用 retain() 方法），就必须调用 release() 方法")]),e._v(" "),t("h2",{attrs:{id:"实战"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实战"}},[e._v("#")]),e._v(" 实战")]),e._v(" "),t("p",[e._v("了解了以上 API 之后，最后我们使用上述 API 来 写一个简单的 demo")]),e._v(" "),t("blockquote",[t("p",[e._v("ByteBufTest.java")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class ByteBufTest {\n    public static void main(String[] args) {\n        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer(9, 100);\n\n        print("allocate ByteBuf(9, 100)", buffer);\n\n        // write 方法改变写指针，写完之后写指针未到 capacity 的时候，buffer 仍然可写\n        buffer.writeBytes(new byte[]{1, 2, 3, 4});\n        print("writeBytes(1,2,3,4)", buffer);\n\n        // write 方法改变写指针，写完之后写指针未到 capacity 的时候，buffer 仍然可写, 写完 int 类型之后，写指针增加4\n        buffer.writeInt(12);\n        print("writeInt(12)", buffer);\n\n        // write 方法改变写指针, 写完之后写指针等于 capacity 的时候，buffer 不可写\n        buffer.writeBytes(new byte[]{5});\n        print("writeBytes(5)", buffer);\n\n        // write 方法改变写指针，写的时候发现 buffer 不可写则开始扩容，扩容之后 capacity 随即改变\n        buffer.writeBytes(new byte[]{6});\n        print("writeBytes(6)", buffer);\n\n        // get 方法不改变读写指针\n        System.out.println("getByte(3) return: " + buffer.getByte(3));\n        System.out.println("getShort(3) return: " + buffer.getShort(3));\n        System.out.println("getInt(3) return: " + buffer.getInt(3));\n        print("getByte()", buffer);\n\n\n        // set 方法不改变读写指针\n        buffer.setByte(buffer.readableBytes() + 1, 0);\n        print("setByte()", buffer);\n\n        // read 方法改变读指针\n        byte[] dst = new byte[buffer.readableBytes()];\n        buffer.readBytes(dst);\n        print("readBytes(" + dst.length + ")", buffer);\n\n    }\n\n    private static void print(String action, ByteBuf buffer) {\n        System.out.println("after ===========" + action + "============");\n        System.out.println("capacity(): " + buffer.capacity());\n        System.out.println("maxCapacity(): " + buffer.maxCapacity());\n        System.out.println("readerIndex(): " + buffer.readerIndex());\n        System.out.println("readableBytes(): " + buffer.readableBytes());\n        System.out.println("isReadable(): " + buffer.isReadable());\n        System.out.println("writerIndex(): " + buffer.writerIndex());\n        System.out.println("writableBytes(): " + buffer.writableBytes());\n        System.out.println("isWritable(): " + buffer.isWritable());\n        System.out.println("maxWritableBytes(): " + buffer.maxWritableBytes());\n        System.out.println();\n    }\n}\n\n')])])]),t("p",[e._v("最后，控制台输出")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("after ===========allocate ByteBuf(9, 100)============\ncapacity(): 9\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 0\nisReadable(): false\nwriterIndex(): 0\nwritableBytes(): 9\nisWritable(): true\nmaxWritableBytes(): 100\n\nafter ===========writeBytes(1,2,3,4)============\ncapacity(): 9\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 4\nisReadable(): true\nwriterIndex(): 4\nwritableBytes(): 5\nisWritable(): true\nmaxWritableBytes(): 96\n\nafter ===========writeInt(12)============\ncapacity(): 9\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 8\nisReadable(): true\nwriterIndex(): 8\nwritableBytes(): 1\nisWritable(): true\nmaxWritableBytes(): 92\n\nafter ===========writeBytes(5)============\ncapacity(): 9\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 9\nisReadable(): true\nwriterIndex(): 9\nwritableBytes(): 0\nisWritable(): false\nmaxWritableBytes(): 91\n\nafter ===========writeBytes(6)============\ncapacity(): 64\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 10\nisReadable(): true\nwriterIndex(): 10\nwritableBytes(): 54\nisWritable(): true\nmaxWritableBytes(): 90\n\ngetByte(3) return: 4\ngetShort(3) return: 1024\ngetInt(3) return: 67108864\nafter ===========getByte()============\ncapacity(): 64\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 10\nisReadable(): true\nwriterIndex(): 10\nwritableBytes(): 54\nisWritable(): true\nmaxWritableBytes(): 90\n\nafter ===========setByte()============\ncapacity(): 64\nmaxCapacity(): 100\nreaderIndex(): 0\nreadableBytes(): 10\nisReadable(): true\nwriterIndex(): 10\nwritableBytes(): 54\nisWritable(): true\nmaxWritableBytes(): 90\n\nafter ===========readBytes(10)============\ncapacity(): 64\nmaxCapacity(): 100\nreaderIndex(): 10\nreadableBytes(): 0\nisReadable(): false\nwriterIndex(): 10\nwritableBytes(): 54\nisWritable(): true\nmaxWritableBytes(): 90\n\n")])])]),t("blockquote",[t("p",[e._v("完整代码已放置 "),t("a",{attrs:{href:"https://github.com/lightningMan/flash-netty/tree/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BD%BD%E4%BD%93ByteBuf",target:"_blank",rel:"noopener noreferrer"}},[e._v("github"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("相信大家在了解了 ByteBuf 的结构之后，不难理解控制台的输出")]),e._v(" "),t("h2",{attrs:{id:"总结"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),t("ol",[t("li",[e._v("本小节，我们分析了 Netty 对二进制数据的抽象 ByteBuf 的结构，本质上它的原理就是，它引用了一段内存，这段内存可以是堆内也可以是堆外的，然后用引用计数来控制这段内存是否需要被释放，使用读写指针来控制对 ByteBuf 的读写，可以理解为是外观模式的一种使用")]),e._v(" "),t("li",[e._v("基于读写指针和容量、最大可扩容容量，衍生出一系列的读写方法，要注意 read/write 与 get/set 的区别")]),e._v(" "),t("li",[e._v("多个 ByteBuf 可以引用同一段内存，通过引用计数来控制内存的释放，遵循谁 retain() 谁 release() 的原则")]),e._v(" "),t("li",[e._v("最后，我们通过一个具体的例子说明 ByteBuf 的实际使用")])]),e._v(" "),t("h2",{attrs:{id:"思考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[e._v("#")]),e._v(" 思考")]),e._v(" "),t("p",[e._v("slice 方法可能用在什么场景？欢迎留言讨论。")])])}),[],!1,null,null,null);t.default=n.exports}}]);