import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,d as a,a as l,b as s,f as h,w as k,r as p,o as r}from"./app-D0iB2z-A.js";const d={};function o(g,i){const t=p("RouteLink");return r(),n("div",null,[i[3]||(i[3]=a(`<h1 id="_4-sw通过插件增强类" tabindex="-1"><a class="header-anchor" href="#_4-sw通过插件增强类"><span>4. sw通过插件增强类</span></a></h1><h2 id="sw-通过插件增强java类" tabindex="-1"><a class="header-anchor" href="#sw-通过插件增强java类"><span>SW 通过插件增强Java类</span></a></h2><p>代码位置： <code>org.apache.skywalking.apm.agent.SkyWalkingAgent.Transformer#transform</code></p><blockquote><p>在这之前，sw 已经寻找到了所有的插件。<br> 接下来的操作，就是sw要使用这些插件，利用插件增强目标的Java类。<br> 而本次讨论的就是 sw 如何使用 插件增强 目标Java类</p></blockquote><h2 id="_1-skywalking-如何匹配插件" tabindex="-1"><a class="header-anchor" href="#_1-skywalking-如何匹配插件"><span>1. skyWalking 如何匹配插件</span></a></h2><p>再sky walking 的插件定义中，有这样一个函数：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    /**</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     * Define the {@link ClassMatch} for filtering class.</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     *</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     * </span><span style="--shiki-light:#A626A4;--shiki-light-font-style:italic;--shiki-dark:#C678DD;--shiki-dark-font-style:italic;">@return</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> {@link ClassMatch}</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     */</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    protected</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> abstract</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> ClassMatch</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> enhanceClass</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个函数用于指定插件增强哪个Java类。需要注意的是，这个函数的返回值不是一个 Class 对象，而是一个 ClassMatch 对象。<br> 这个类的功能类似于一个过滤器，用于通过指定的规则，匹配出需要增强的类。</p><ul><li>NameMatch： 通过类名匹配</li><li>PrefixMatch：通过类名前缀匹配</li><li>InterfaceMatch：通过接口匹配</li><li>MultiClassNameMatch：通过多个类名匹配<br> ... 其他的实现方式就不一一列举了</li></ul><p>找到合适的插件之后，就会调用插件的<code>enhance</code>函数，来增强目标类。<br><code>AbstractClassEnhancePluginDefine#enhance</code><br> 增强分为两类：</p><ul><li>增强类实例函数 <ul><li>包括构造函数</li><li>对象函数</li></ul></li><li>增强静态函数</li></ul><h2 id="_1-2-skywalking-如何增强类实例函数" tabindex="-1"><a class="header-anchor" href="#_1-2-skywalking-如何增强类实例函数"><span>1.2 skyWalking 如何增强类实例函数</span></a></h2><p>再上面说到，会调用插件的<code>enhance</code>函数，来增强目标类。<br> 再enhance函数中，声明了两种方法来增强一个Java类：</p><ul><li><code>enhanceInstance</code>：增强类实例函数、构造函数</li><li><code>enhanceClass</code>：增强静态函数</li></ul><p>两者的增强流程其实大差不差，大致是以下步骤：</p><ol><li>获取当前插件的拦截点</li></ol><ul><li>静态函数拦截点 <code>getStaticMethodsInterceptPoints</code></li><li>实例函数拦截点 <code>getInstanceMethodsInterceptPoints</code></li><li>构造函数拦截点 <code>getConstructorsInterceptPoints</code></li></ul><ol start="2"><li>遍历拦截点，对每一个拦截点进行增强</li></ol><h2 id="_1-3-skywalking-具体如何增强一个java类" tabindex="-1"><a class="header-anchor" href="#_1-3-skywalking-具体如何增强一个java类"><span>1.3 skyWalking 具体如何增强一个Java类</span></a></h2>`,19)),l("p",null,[i[1]||(i[1]=s("通过告诉byteBuddy的builder 拦截",-1)),h(t,{to:"/Java/skywalking/skywalking-java/5.%20%E5%90%AF%E5%8A%A8sw%E7%9A%84%E6%9C%8D%E5%8A%A1.html"},{default:k(()=>i[0]||(i[0]=[s("5. 启动sw的服务.md",-1)])),_:1,__:[0]}),i[2]||(i[2]=s("规则，将指定的函数执行，委托给我们组件声明的目标函数去执行。",-1))]),i[4]||(i[4]=a(`<p>下面其实就是一段 很正常的byteBuddy代码，用于增强一个Java类的构造函数。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">newClassBuilder </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> newClassBuilder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">constructor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">constructorInterceptPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConstructorMatcher</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 拦截构造函数</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                    // 使用默认拦截规则</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                    .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">intercept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">SuperMethodCall</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">INSTANCE</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">andThen</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MethodDelegation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">withDefaultConfiguration</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                         // 将此函数，委托给谁去执行</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">to</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> ConstructorInter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">constructorInterceptPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getConstructorInterceptor</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), classLoader), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">delegateNamingResolver</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(constructorInterceptPoint))));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过上面代码声明，byteBuddy就添加了类的构造函数的拦截规则。<br> 会在实例化一个类的时候，调用<code>ConstructorInter</code>的<code>intercept</code>函数，来执行我们的目标函数。<br> 那时候，我们就可以再声明的<code>intercept</code>函数中，执行我们的目标函数了。进行自定义操作了！！！</p><h3 id="拦截对象函数" tabindex="-1"><a class="header-anchor" href="#拦截对象函数"><span>拦截对象函数</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">newClassBuilder </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> newClassBuilder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(junction)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 指定函数拦截规则</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                     .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">intercept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MethodDelegation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">withDefaultConfiguration</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 使用默认拦截规则</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                                           // 将此函数，委托给谁去执行</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                        .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">to</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> InstMethodsInter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(interceptor, classLoader), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">delegateNamingResolver</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(instanceMethodsInterceptPoint)));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="拦截静态函数" tabindex="-1"><a class="header-anchor" href="#拦截静态函数"><span>拦截静态函数</span></a></h3><p>指定静态函数的拦截，将其委托给我们声明的目标函数去执行。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">newClassBuilder </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> newClassBuilder</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">method</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">isStatic</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">().</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">and</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">staticMethodsInterceptPoint</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">getMethodsMatcher</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()))</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                      .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">intercept</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">MethodDelegation</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">withDefaultConfiguration</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">                                          .</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">to</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> StaticMethodsInter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(interceptor), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">delegateNamingResolver</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">resolve</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(staticMethodsInterceptPoint)));</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8))])}const y=e(d,[["render",o]]),B=JSON.parse('{"path":"/Java/skywalking/skywalking-java/4.%20sw%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E5%A2%9E%E5%BC%BA%E7%B1%BB.html","title":"4. sw通过插件增强类","lang":"zh-CN","frontmatter":{"description":"4. sw通过插件增强类 SW 通过插件增强Java类 代码位置： org.apache.skywalking.apm.agent.SkyWalkingAgent.Transformer#transform 在这之前，sw 已经寻找到了所有的插件。 接下来的操作，就是sw要使用这些插件，利用插件增强目标的Java类。 而本次讨论的就是 sw 如何使用 ...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"4. sw通过插件增强类\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-29T04:57:29.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"heihei180\\",\\"url\\":\\"https://github.com/heihei180\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/note/Java/skywalking/skywalking-java/4.%20sw%E9%80%9A%E8%BF%87%E6%8F%92%E4%BB%B6%E5%A2%9E%E5%BC%BA%E7%B1%BB.html"}],["meta",{"property":"og:site_name","content":"筆記本首頁"}],["meta",{"property":"og:title","content":"4. sw通过插件增强类"}],["meta",{"property":"og:description","content":"4. sw通过插件增强类 SW 通过插件增强Java类 代码位置： org.apache.skywalking.apm.agent.SkyWalkingAgent.Transformer#transform 在这之前，sw 已经寻找到了所有的插件。 接下来的操作，就是sw要使用这些插件，利用插件增强目标的Java类。 而本次讨论的就是 sw 如何使用 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-29T04:57:29.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-29T04:57:29.000Z"}]]},"git":{"createdTime":1754290890000,"updatedTime":1756443449000,"contributors":[{"name":"wanggq10","username":"wanggq10","email":"wanggq10@lenovo.com","commits":2,"url":"https://github.com/wanggq10"}]},"readingTime":{"minutes":2.58,"words":773},"filePathRelative":"Java/skywalking/skywalking-java/4. sw通过插件增强类.md","autoDesc":true}');export{y as comp,B as data};
