import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,d as a,o as n}from"./app-Ck_x_2UU.js";const t={};function l(r,s){return n(),e("div",null,s[0]||(s[0]=[a(`<h1 id="_5-启动skywalking-服务" tabindex="-1"><a class="header-anchor" href="#_5-启动skywalking-服务"><span>5. 启动SkyWalking 服务</span></a></h1><p>上一节，将所有的插件如何激活，如何增强Java类，都已经介绍，，<br> 这里来介绍，如何启动skyWaling的服务.</p><h2 id="_5-1-sw-内部服务插件-bootservice" tabindex="-1"><a class="header-anchor" href="#_5-1-sw-内部服务插件-bootservice"><span>5.1 sw 内部服务插件 BootService</span></a></h2><h3 id="_5-1-1-sw-服务的解释" tabindex="-1"><a class="header-anchor" href="#_5-1-1-sw-服务的解释"><span>5.1.1 sw 服务的解释</span></a></h3><p>再sw中，比如想要发送 指标信息给oap，发送trace信息给Oap，就是使用了这个机制，创建一个服务对象，然后实现自己的逻辑。<br> 比如 发送jvm的指标信息，就说通过插件 <code>JVMMetricsSender</code> 实现的， 这个插件默认使用 grpc 协议发送数据给OAP。<br> 当然他还有个实现类 <code>KafkaJVMMetricsSender</code> ，他也是将 JVM 的指标信息发送给OAP，但是他使用的是kafka。</p><h3 id="_5-1-2-加载所有服务插件" tabindex="-1"><a class="header-anchor" href="#_5-1-2-加载所有服务插件"><span>5.1.2 加载所有服务插件</span></a></h3><p>SW 可以保证再所有插件都加载安装完成之后，查找并启动所有的服务对象。<br> 通过Java SPI 机制，加载所有 <code>BootService</code> 接口的实现类</p><p>需要注意的是，大部分的服务接口都标注了注解：<code>@DefaultImplementor</code> 或者 <code>@OverrideImplementor</code></p><p>如何理解这两个注解？</p><ul><li>DefaultImplementor 默认实现类</li><li>OverrideImplementor 重写实现类</li></ul><p>用上面说到的 <code>JVMMetricsSender</code> 为例，他有两个实现类，一个是 <code>JVMMetricsSender</code> 一个是 <code>KafkaJVMMetricsSender</code>，</p><p>sw 在初期版本，所有的内部组件通讯协议都是GRPC，所以，发送JVM指标信息的实现也是使用GRPC协议来发送的，也就是说 <code>JVMMetricsSender</code> 的功能，<br> 他标注了注解 <code>@DefaultImplementor</code>，声明这种方式是传输指标的默认方式。</p><p>后期，可能有一些较大发服务集群，GRPC可能吞吐率或者其他方面无法达到要求，可以选择Kafka来发送指标信息，这个时候就可以使用 <code>KafkaJVMMetricsSender</code>，<br> 但是也不可以直接修改原始的代码，所以，可以新建一个<code>BootService</code> 的实现类，使用 <code>@OverrideImplementor</code> 来标注这个实现类，声明这个实现类用于覆盖默认实现。</p><p>如：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">DefaultImplementor</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> JVMMetricsSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> BootService</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Runnable</span><span style="--shiki-light:#C18401;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> GRPCChannelListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...  使用grpc 发送消息的具体实现</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#A626A4;--shiki-dark:#E5C07B;">OverrideImplementor</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">JVMMetricsSender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">class</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KafkaJVMMetricsSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> JVMMetricsSender</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> implements</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> KafkaConnectionStatusListener</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ... 使用kafka 发送消息的具体实现</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由上面代码看到，OverrideImplementor 标注了要覆盖 <code>JVMMetricsSender</code> 。</p><h3 id="_5-2-服务的生命周期" tabindex="-1"><a class="header-anchor" href="#_5-2-服务的生命周期"><span>5.2 服务的生命周期</span></a></h3><p>在sw内部的服务，有一个生命周期，或者说类似于模板设计模式。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-java"><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">   prepare</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">   startup</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // ==&gt;  boot(); 对应服务的boot函数</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">   onComplete</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SW 会在加载到所有的服务之后，按照顺序，分别再去调用单独每个服务的这三个函数。</p><p>因此，可以理解为生命周期吧，分别是 准备阶段， 启动阶段， 完成阶段。</p><p>当然，sw会在服务结束时，调用服务的 <code>shutdown()</code> 函数。意味销毁的回调函数，可以用于关闭链接，释放资源等。</p><p><strong>举个例子</strong><br><code>KafkaJVMMetricsSender</code> 在 <code>prepare()</code> 阶段，初始化花村队列，用于存放agent收集到的消息，</p><p><code>KafkaProducerManager</code> 在 <code>boot</code> 阶段，链接kafka，<code>shutdown()</code> 阶段，关闭kafka链接。</p>`,24)]))}const d=i(t,[["render",l]]),k=JSON.parse('{"path":"/Java/skywalking/skywalking-java/5.%20%E5%90%AF%E5%8A%A8sw%E7%9A%84%E6%9C%8D%E5%8A%A1.html","title":"5. 启动SkyWalking 服务","lang":"zh-CN","frontmatter":{"description":"5. 启动SkyWalking 服务 上一节，将所有的插件如何激活，如何增强Java类，都已经介绍，， 这里来介绍，如何启动skyWaling的服务. 5.1 sw 内部服务插件 BootService 5.1.1 sw 服务的解释 再sw中，比如想要发送 指标信息给oap，发送trace信息给Oap，就是使用了这个机制，创建一个服务对象，然后实现自己...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"5. 启动SkyWalking 服务\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-08-04T07:01:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"heihei180\\",\\"url\\":\\"https://github.com/heihei180\\"}]}"],["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/note/Java/skywalking/skywalking-java/5.%20%E5%90%AF%E5%8A%A8sw%E7%9A%84%E6%9C%8D%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"筆記本首頁"}],["meta",{"property":"og:title","content":"5. 启动SkyWalking 服务"}],["meta",{"property":"og:description","content":"5. 启动SkyWalking 服务 上一节，将所有的插件如何激活，如何增强Java类，都已经介绍，， 这里来介绍，如何启动skyWaling的服务. 5.1 sw 内部服务插件 BootService 5.1.1 sw 服务的解释 再sw中，比如想要发送 指标信息给oap，发送trace信息给Oap，就是使用了这个机制，创建一个服务对象，然后实现自己..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-04T07:01:30.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-04T07:01:30.000Z"}]]},"git":{"createdTime":1754290890000,"updatedTime":1754290890000,"contributors":[{"name":"wanggq10","username":"wanggq10","email":"wanggq10@lenovo.com","commits":1,"url":"https://github.com/wanggq10"}]},"readingTime":{"minutes":2.47,"words":740},"filePathRelative":"Java/skywalking/skywalking-java/5. 启动sw的服务.md","autoDesc":true}');export{d as comp,k as data};
